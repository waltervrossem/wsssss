#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""MESA grid overseer."""

import itertools
import multiprocessing as mp
import os
import signal
import subprocess
import sys
import time
from argparse import ArgumentParser


def get_parser():
    """"""
    # TODO: Add option to compile star once and then copy the executable?
    parser = ArgumentParser(description="""
    This program will run a MESA grid created with the `setup_inlists.py` script.
    """)
    try:
        env_OMP_NUM_THREADS = os.environ['OMP_NUM_THREADS']
    except KeyError:
        print('Environment variable OMP_NUM_THREADS not set, using `nproc`.')
        env_OMP_NUM_THREADS = mp.cpu_count()

    parser.add_argument('grid_dir', type=str, default='.', nargs='?',
                        help='The directory which contains each run for MESA to run in a separate sub-directory.')
    parser.add_argument('--sub-dirs', '-d', nargs='*', type=str, default='',
                        help='The names of the sub directories if they are not named 0000 0001 etc.')
    parser.add_argument('--base-work-dir', '-b', type=str, default='$MESA_DIR/star/work',
                        help='Directory to use as the base work directory. A copy will be made and `star` executed '
                             'in this directory.')
    parser.add_argument('--restart', '-re', action='store_const', const=True, default=False,
                        help='Restart from the last photo in each run\'s photos directory. If no photo is found, '
                             'start a new run.')
    parser.add_argument('--source', type=str, default='',
                        help='Source this file before running `star`.')
    parser.add_argument('--cmd-pre', type=str, default='',
                        help='Command to run before starting the grid. Can be a file.')
    parser.add_argument('--cmd-pre-each', type=str, default='',
                        help='Command to run directly before starting `star` in each directory. Can be a file.')
    parser.add_argument('--cmd-main', type=str, default='./rn',
                        help='Command to run MESA. Defaults to `./rn`.')
    parser.add_argument('--cmd-post-each', type=str, default='',
                        help='Command to run directly after `star` has finished in each directory. Can be a file.')
    parser.add_argument('--cmd-post', type=str, default='',
                        help='Command to run after the grid is finished. Can be a file.')
    parser.add_argument('--verbose', '-v', action='store_const', const=True, default=False,
                        help='Print info about what the script is doing.')
    parser.add_argument('--num-mesa', '-n', type=int, default=1,
                        help='Number of instances of MESA to run at once.')
    parser.add_argument('--OMP_NUM_THREADS', '-j', type=int, default=env_OMP_NUM_THREADS,
                        help='Value of the OMP_NUM_THREADS environment variable to set before running `star`. '
                             '`num-mesa` times `OMP_NUM_THREADS` cannot be larger than `nproc`.')
    parser.add_argument('--debug', action='store_const', const=True, default=False,
                        help='Print info about what the script is doing.')
    parser.add_argument('--skip-if-file-exists', type=str, default='',
                        help='Skip running MESA in this work_dir if this file exists in work_dir. '
                             'Can use MESAGO_LOG_FILE to look for log file generated by this script.'
                             'WORK_DIR and RUN_NAME will be replaced with the `run_name`, so '
                             'WORK_DIR/out_RUN_NAME becomes $GRID_DIR/0000/out_0000.')
    parser.add_argument('--log-path', type=str, default='out_RUN_NAME',
                        help='Log file path, WORK_DIR, and RUN_NAME will be replaced by their '
                             'corresponding values.')
    parser.add_argument('--task-share', action='store_const', const=True, default=False,
                        help='Set the slurm task-id and only do runs assigned to that task-id.')
    return parser


def check_cores(args):
    """Check and process args."""
    nproc = os.cpu_count()
    req_cores = args.num_mesa * args.OMP_NUM_THREADS

    if req_cores > nproc:
        raise ValueError(f'Number or required cores ({req_cores}) larger than available cores ({nproc}).')
    return req_cores, nproc


def process_args(args):
    """"""

    def expand_path(path):
        return os.path.abspath(os.path.expandvars(path))

    args.base_work_dir = expand_path(args.base_work_dir)
    args.grid_dir = expand_path(args.grid_dir)

    if args.source != '':
        args.source = expand_path(args.source)

    if args.log_path != '':
        if not (('WORK_DIR' in args.log_path) or ('RUN_NAME' in args.log_path)):  #
            raise ValueError('log-path must contain one or both of WORK_DIR or RUN_NAME in its path.')

    if args.skip_if_file_exists != '':
        if not (('WORK_DIR' in args.log_path) or ('RUN_NAME' in args.log_path)):  #
            raise ValueError('skip-if-file-exists must contain one or both of WORK_DIR or RUN_NAME in its path.')

    return args


def start_mesa(args, run_name):
    logger.info(f'Starting {run_name}')

    os.chdir(os.path.join(args.grid_dir, run_name))
    if args.verbose:
        logger.info('Current directory:')
        logger.info(os.getcwd())

    if args.log_path == '':
        log_file = os.path.join(args.grid_dir, 'out_' + run_name)
    else:
        log_file = os.path.join(args.grid_dir, args.log_path). \
            replace('WORK_DIR', run_name).replace('RUN_NAME', run_name)
    os.makedirs(os.path.dirname(log_file), exist_ok=True)

    if args.skip_if_file_exists:
        if args.skip_if_file_exists == 'MESAGO_LOG_FILE':
            skip_check_fpath = log_file
        else:
            skip_check_fpath = os.path.join(args.grid_dir, args.skip_if_file_exists).replace('WORK_DIR', run_name). \
                replace('RUN_NAME', run_name)

        if os.path.exists(skip_check_fpath):
            logger.info(f'Skipping {run_name}, skip file found {skip_check_fpath}.')
            return run_name, 'Skip file found.'

    with open(log_file,
              'w') as handle:  # Create file so other processes can find it before someting actually writes to it
        handle.write('')
        handle.flush()
        os.fsync(handle)

    pre_cmd_str = f'export OMP_NUM_THREADS={args.OMP_NUM_THREADS}; '
    if args.source != '':
        pre_cmd_str = f'. {args.source}; ' + pre_cmd_str

    if args.cmd_pre_each != '':
        run_cmd(args.cmd_pre_each, shell=True)

    if not os.path.exists('star'):
        run_cmd('./clean && ./mk', shell=True)

    if args.debug:
        out = run_cmd(f'{os.path.dirname(os.path.abspath(__file__))}/testing_star.py {run_name}')
        if args.cmd_post_each != '':
            run_cmd(args.cmd_post_each)
        return run_name, out

    if os.path.exists('photos'):
        photos = os.listdir('photos')
    else:
        photos = []
    photos.sort()
    if args.restart and len(photos) > 0:
        photo = photos[-1]

        cmd = pre_cmd_str + f'./re {photo} >> {log_file} 2>&1'
        if args.verbose:
            logger.info(run_name)
            logger.info(cmd)
        out = run_cmd(cmd, split=False, shell=True)
    else:
        cmd = pre_cmd_str + args.cmd_main + '  2>&1'
        if args.verbose:
            logger.info(run_name)
            logger.info(cmd)
        out = run_cmd(cmd, split=False, shell=True, to_file=log_file)

    if args.cmd_post_each != '':
        run_cmd(args.cmd_post_each, shell=True)

    logger.info(f'Finished {run_name}')

    return run_name, out


def run_cmd(cmd, capture_output=False, split=False, to_file='', file_mode='w', **kwargs):
    if file_mode not in ['a', '-a', 'w']:
        raise ValueError('`file_mode` must be one of `a`, `-a`, or `w`.')

    if capture_output and to_file != '':
        logger.warning('Cannot simultaneously capture output and write to file if `split=True`, setting to False.')
        split = False

    if split:
        cmd = cmd.split()

    if to_file != '' and not capture_output:
        with open(to_file, file_mode) as f:
            return subprocess.run(cmd, stdout=f, stdin=f, **kwargs)
    if capture_output:
        if to_file != '':
            if file_mode == 'a':
                file_mode = '-a'
            elif file_mode == 'w':
                file_mode = ''
            return subprocess.run(cmd + f'| tee {file_mode} {to_file}', stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                  shell=True, **kwargs)
        return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)
    return subprocess.run(cmd, **kwargs)


def check_dir(args, dirpath):
    for fname in ['rn', 're', 'clean', args.cmd_main]:
        fpath = os.path.join(dirpath, fname)
        if not os.path.isfile(fpath):
            raise FileNotFoundError(f'File `{fname}` does not exist at the expected location:\n'
                                    f'{fpath}')
    if args.restart:
        pass


def get_subdirs(args):
    if args.sub_dirs != '':
        sub_dirs = args.sub_dirs
    else:
        sub_dirs = []
        for item in os.listdir(args.grid_dir):
            item_path = os.path.join(args.grid_dir, item)
            if os.path.isdir(item_path) and item.isdigit():
                sub_dirs.append(item)
        sub_dirs.sort()
    return sub_dirs


def main(args):
    # TODO: include walltime?

    if args.verbose:
        print('Parsed inputs:')
        for key, value in args.__dict__.items():
            print(f'{key:<16}= {value}')
        print('')

    check_cores(args)
    check_dir(args, args.base_work_dir)

    if args.cmd_pre != '':
        run_cmd(args.cmd_pre, shell=True)

    sub_dirs = get_subdirs(args)
    if args.verbose:
        print('Sub-directories:')
        for subdir in sub_dirs:
            print(subdir)
        print('')

    pool = mp.Pool(args.num_mesa)
    arguments = list(zip(itertools.repeat(args), sub_dirs))
    if args.task_share:
        try:
            n_tasks = int(os.environ['SLURM_ARRAY_TASK_COUNT'])
            task_id = int(os.environ['SLURM_ARRAY_TASK_ID'])
            task_id_min = int(os.environ['SLURM_ARRAY_TASK_MIN'])
            task_id = task_id - task_id_min
        except KeyError:  # Not running with a task array
            n_tasks = 1
            task_id = 0
        print(f'n_tasks={n_tasks}')
        print(f'task_id={task_id}')
    else:
        n_tasks = 1
        task_id = 0
    results = pool.starmap(start_mesa, arguments[task_id::n_tasks])
    print(results)

    if args.cmd_post != '':
        run_cmd(args.cmd_post, shell=True)


def run():
    args = " ".join(sys.argv[1:])
    os.system(f'{__file__} {args}')


if __name__ == "__main__":
    try:
        import setproctitle

        setproctitle.setproctitle('MESAgo')
    except ModuleNotFoundError:
        print('Module setproctitle not found, will not set process name.')
        pass

    signal.signal(signal.SIGTERM, signal.default_int_handler)
    signal.signal(signal.SIGINT, signal.default_int_handler)

    t_start = time.time()

    parser = get_parser()
    args = parser.parse_args()

    args = process_args(args)

    logger = mp.get_logger()

    if args.debug:
        args.verbose = True
        logger.setLevel('DEBUG')
    else:
        logger.setLevel('INFO')

    main(args)
